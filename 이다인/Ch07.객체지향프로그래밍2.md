## 1. 상속

**상속**

- 기존의 클래스로 새로운 클래스를 작성하는 것(코드의 재사용)
- 두 클래스를 부모와 자식으로 관계 맺어주는 것

```java
class 자식클래스 extends 부모클래스 {
    // ...
}
```

```java
class Parent { }
class Child extends Parent {
    // ...
}
```



- 자손은 조상(부모의 부모...)의 모든 멤버를 상속받는다(생성자, 초기화블럭 제외)
- 자손의 멤버 개수는 조상보다 적을 수 없다(같거나 많다)

```java
class Parent {
    int age;
}
class Child extends Parent { }
```

<img src="Ch07.객체지향프로그래밍2.assets/image-20220621154054196.png" alt="image-20220621154054196" style="zoom: 67%;" />



- 자손의 변경은 조상에 영향을 미치지 않는다.

```java
class Parent {
    int age;
}
class Child extends Parent {
    void play() {
        System.out.println("놀자~");
    }
}
```

<img src="Ch07.객체지향프로그래밍2.assets/image-20220621154217743.png" alt="image-20220621154217743" style="zoom:67%;" />



상속을 받을 때와 안 받을 때의 차이

- 상속을 받으면 부모가 바뀌면 자식도 바뀐다. 단, 자식이 바뀌어도 부모는 바뀌지 않는다

```java
class Point {
    int x;
    int y;
}

// 1
class Point3D {
    int x;
    int y;
    int z;
}

// 2
class Point3D extends Point {
    int z;
}
```

```java
Point3D p = new Point3D();
```

<img src="Ch07.객체지향프로그래밍2.assets/image-20220621154526301.png" alt="image-20220621154526301" style="zoom:67%;" />



```java
class Tv {
    boolean power;
    int channel;
    
    void power();
    void channelUp();
    void channelDown();
}

class SmartTv extends Tv {
    boolean caption;
    void displayCaption(String text) {
        if (caption) { // 캡션상태가 on(true)일때만 text 보여줌
            System.out.prinln(text);
        }
    }
}

class Ex7_1 {
    public static void main(String args[]){
        SmartTv stv = new SmartTv();
        stv.channel = 10;
        stv.channelUp();
        System.out.println(stv.channel);
        stv.displayCaption("Hello, World");
        stv.caption = true;
        stv.displayCaption("Hello, World");
    }
}
```



**포함 관계**

포함

- 클래스의 멤버로 참조변수를 선언하는 것

```java
class Circle {
    int x;
    int y;
    int z;
}
```

```java
class Point {
    int x;
    int y;
}

class Circle {
    Point c = new Point(); // Circle이 Point를 포함
    int r;
}
```

![image-20220621155758839](Ch07.객체지향프로그래밍2.assets/image-20220621155758839.png)



```java
class Car {
    Engine e = new Engine(); // 엔진
    Door[] d = new Door[4]; // 문, 문의 개수를 넷으로 가정하고 배열처리
}
```



**클래스 간의 관계 결정하기**

상속관계

- A는 B이다. (is ~a)

포함관계 (사실 대부분 포함, 90% 이상)

- A는 B를 가지고 있다. (has ~a)



```java
// 포함
class Circle {
    Point c = new Point();
    int r;
}

// 상속
class Circle extends Point {
    int r;
}
```

포함: 원은 점을 가지고 있다 (o)

상속: 원은 점이다 (x)



```java
class Point {
    int x;
    int y;
}

// 상속
class Circle extends Point {
    int r;
}

public class InheritanceTest {
    public static void main(String[] args) {
        Circle c = new Circle();
        c.x = 1;
        c.y = 2;
        c.r = 3;
        System.out.println("c.x = " + c.x);
        System.out.println("c.y = " + c.y);
        System.out.println("c.r = " + c.r);
    }
}

// 포함
class Circle2 {
    Point p = new Point(); // 객체생성: 참조변수의 초기화.안하면 null
    int r;
    // 위에서 new Point();로 초기화 안해주면 밑에서 생성자로 초기화 해줘야 함. 안그럼 null 값.
    //Circle() {
        //p = new Point();
    //}
}

public class InheritanceTest {
    public static void main(String[] args) {
        Circle2 c = new Circle2();
        c.p.x = 1;
        c.p.y = 2;
        c.r = 3;
        System.out.println("c.p.x = " + c.p.x);
        System.out.println("c.p.y = " + c.p.y);
        System.out.println("c.r = " + c.r);
    }
}

```



**단일 상속**

java는 단일 상속(하나의 부모만 상속)만 허용한다. (c++은 다중상속 허용)

```java
class TvDvD extends Tv, DvD { // 에러. 조상은 하나만 허용
    //...
}
```

문제점: 다른 부모에 같은 메서드 있을 시 충돌남.

=> 인터페이스 이용하면 충돌 문제 해결하고 다중 상속처럼 쓸 수 있다.

=> 비중이 높은 클래스 하나만 상속관계, 나머지는 포함관계

![image-20220621162958432](Ch07.객체지향프로그래밍2.assets/image-20220621162958432.png)



**Object 클래스 - 모든 클래스의 조상**

- 부모가 없는 클래스는 자동적으로 Object클래스를 상속받게 된다.

- 모든 클래스는 Object클래스에 정의된 11개의 메서드를 상속받는다.
  - toString(), equals(Object obj), hashCode(), ...

![image-20220621163341046](Ch07.객체지향프로그래밍2.assets/image-20220621163341046.png)



toString()

클래스이름@객체주소값(정확한주소값은아님)

![image-20220621164021041](Ch07.객체지향프로그래밍2.assets/image-20220621164021041.png)

참조변수 넣으면 .toString() 생략해도 같은 결과





## 2. 오버라이딩

**(메서드)오버라이딩**

상속받은 조상의 메서드를 자신에 맞게 변경하는 것 (overide 덮어쓰다)

- 선언부 변경불가, 내용만 변경가능(구현부 { })

```java
class Point {
    int x;
    int y;
	
    String getLocation() {
        return "x " + x + ", y :" + y;
    }
}

class Point3D extends Point {
    int z;
    
    String getLocation() { // 오버라이딩(같은 기능)
        return "x " + x + ", y :" + y + ", z :" + z;
    }
}
```



실습

```java
class Point3 extends Object{
    int x;
    int y;

    Point3(int x, int y){
        this.x = x;
        this.y = y;
    }

    // Object클래스의 toString()을 오버라이딩
    public String toString() {
        return "x:"+x+",y:"+y;
    }
}

public class OverrideTest {
    public static void main(String[] args) {
        Point3 p = new Point3(3,5);
        System.out.println(p);
    }
}
```



**오버라이딩의 조건**

- 선언부가 조상 클래스의 메서드와 일치해야 한다.

<img src="Ch07.객체지향프로그래밍2.assets/image-20220621171801350.png" alt="image-20220621171801350" style="zoom:67%;" />

- 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.
- 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.

<img src="Ch07.객체지향프로그래밍2.assets/image-20220621171907410.png" alt="image-20220621171907410" style="zoom:67%;" />



**참조변수 super** (this와 비슷)

- 객체 자신을 가리키는 참조변수. 인스턴스 메서드(생성자) 내에만 존재
- 조상의 멤버(super)를 자신의 멤버(this)와 구별할 때 사용(this는 lv와 iv 구별에 사용)

```java
class Ex7_2 {
    public static void main(String args[]) {
        Child c = new Child();
        c.method();
    }
}

class Parent { int x = 10; /* super.x */ }

class Child extends Parent {
    int x = 20;
    
    void method() {
        System.out.println("x=" + x); // 20
        System.out.println("this.x=" + this.x); // 20
        System.out.println("super.x=" + super.x); // 10
    }
}
```

```java
class Ex7_3 {
    public static void main(String args[]) {
        Child2 c = new Child2();
        c.method();
    }
}

class Parent { int x = 10; /* super.x와 this.x 둘 다 가능 */ }

class Child2 extends Parent {
    void method() {
        System.out.println("x=" + x); // 10
        System.out.println("this.x=" + this.x); // 10
        System.out.println("super.x=" + super.x); // 10
    }
}
```



**super() - 조상의 생성자**

- 조상의 생성자를 호출할 때 사용
  - 상속: 생성자, 초기화 블럭은 상속이 안된다!!
- 조상의 멤버는 조상의 생성자를 호출해서 초기화

![image-20220621173156041](Ch07.객체지향프로그래밍2.assets/image-20220621173156041.png)

```java
Point3D(int x, int y, int z) {
    super(x,y); // 조상클래스의 생성자 Point(int x, int y)를 호출. 초기화
    this.z = z; // 자신의 멤버를 초기화
}
```



- 생성자의 첫 줄에 반드시 생성자를 호출해야 한다. 그렇지 않으면 컴파일러가 생성자의 첫 줄에 super();를 삽입

<img src="Ch07.객체지향프로그래밍2.assets/image-20220621173434715.png" alt="image-20220621173434715" style="zoom:67%;" />



예제(모든 생성자는 첫 줄에 반드시 생성자를 호출해야 한다.)

![image-20220621173906625](Ch07.객체지향프로그래밍2.assets/image-20220621173906625.png)

**기본 생성자 작성 필수로 하는게 좋다!!!**





## 3. package와 import

**패키지(package)**

- 서로 관련된 클래스의 묶음
- 클래스는 클래스 파일(*.class), 패키지는 폴더. 하위 패키지는 하위 폴더
- 클래스의 실제 이름(full name)은 패키지를 포함(java.lang.String)
- rt.jar는 클래스들을 압축한 파일(JDK설치경로 \jre\lib에 위치)
  - Java9부터는 사라짐. module개념써서 module로 나뉨



**패키지의 선언**

- 패키지는 소스파일의 첫 번째 문장으로 단 한번 선언
- 같은 소스 파일의 클래스들은 모두 같은 패키지에 속하게 된다
- 패키지 선언이 없으면 이름없는(unnamed) 패키지에 속하게 된다

<img src="Ch07.객체지향프로그래밍2.assets/image-20220621174512726.png" alt="image-20220621174512726" style="zoom:67%;" />



![image-20220621175721177](Ch07.객체지향프로그래밍2.assets/image-20220621175721177.png)



**클래스 패스**

다음에 다시.. 



**import문**

- 클래스를 사용할 때 패키지이름을 생략할 수 있다
- 컴파일러에게 클래스가 속한 패키지를 알려준다
  - 인텔리제이 import 단축키: ctrl alt O

![image-20220621180630111](Ch07.객체지향프로그래밍2.assets/image-20220621180630111.png)

- java.lang패키지의 클래스는 import하지 않고도 사용할 수 있다
  - String, Object, System, Thread



**import문의 선언**

```txt
import 패키지명.클래스명;
또는
import 패키지명.*;
```

- import문은 패키지문과 클래스선언의 사이에 선언한다. 

![image-20220621180849649](Ch07.객체지향프로그래밍2.assets/image-20220621180849649.png)



- import문은 컴파일 시에 처리되므로 프로그램의 성능에 영향없음.
  - import는 컴파일러를 위한 것. 이 클래스가 어떤 패키지에 있는지 알려주는 것.

![image-20220621181119871](Ch07.객체지향프로그래밍2.assets/image-20220621181119871.png)

- 다음의 두 코드는 서로 의미가 다르다.

![image-20220621190659275](Ch07.객체지향프로그래밍2.assets/image-20220621190659275.png)

- 이름이 같은 클래스가 속한 두 패키지를 import할 때는 클래스 앞에 패키지명을 붙여줘야 한다.

![image-20220621190743246](Ch07.객체지향프로그래밍2.assets/image-20220621190743246.png)



**static import문**

static멤버를 사용할 때 클래스 이름을 생략할 수 있게 해준다.

![image-20220621191113135](Ch07.객체지향프로그래밍2.assets/image-20220621191113135.png)

```java
import static java.lang.System.out;
import static java.lang.Math.*;

class Ex7_6 {
    public static void main(String[] args) {
        // System.out.println(Math.random());
        out.println(random());
        
        out.println("Math.PI:" + PI);
    }
}
```

- 웬만하면 필요할 때만 쓸 것!





## 4. 제어자

- 클래스와 클래스의 멤버(멤버 변수, 메서드)에 부가적인 의미 부여(형용사)

![image-20220621191256261](Ch07.객체지향프로그래밍2.assets/image-20220621191256261.png)

- 하나의 대상에 여러 제어자를 같이 사용가능(접근 제어자는 하나만)

```java
public class ModifierTest {
    // 접근제어자를 제일 왼쪽에, static > final
    public static final int WIDTH = 200;
    
    public static void main(String[] args) {
        System.out.println("WIDTH="+WIDTH);
    }
}
```



**static** 

- 클래스의, 공통적인

![image-20220621191735978](Ch07.객체지향프로그래밍2.assets/image-20220621191735978.png)

```java
class StaticTest {
    static int width = 200; // 클래스 변수(cv)
    static int height = 120;
    
    static { // 클래스 초기화 블럭 static { } 
        // static변수의 복잡한 초기화 수행
    }
    
    static int max(int a, int b) { // 클래스 메서드(static메서드)
        return a > b ? a : b; // iv 사용 불가, lv만!
    }
}
```



**final**

- 마지막의, 변경될 수 없는

![image-20220621192128880](Ch07.객체지향프로그래밍2.assets/image-20220621192128880.png)

```java
final class FinalTest { // 조상이 될 수 없는 클래스 (ex. String(보안때문), Math)
    final int MAX_SIZE = 10; // 값을 변경할 수 없는 멤버변수(상수)
    
    final void getMaxSize() { // 오버라이딩(조상메서드 덮어쓰기)할 수 없는 메서드(변경불가)
        final int LV = MAX_SIZE; // 값을 변경할 수 없는 지역변수(상수)
        return MAX_SIZE;
    }
}
```



**abstract**

- 추상의, **미완성의**

![image-20220621192500571](Ch07.객체지향프로그래밍2.assets/image-20220621192500571.png)

```java
abstract class AbstractTest { // 추상 클래스(추상 메서드를 가지고 있는 클래스)
    abstract void move(); // 추상 메서드(구현부{ }가 없는 메서드)
}
```

미완성 설계도 -> 제품 생성 불가. 객체 생성 불가

```java
AbstractTest a = new AbstractTest(); // 에러. 추상 클래스의 인스턴스 생성불가
```

=> 상속을 통해서 메서드 완성을 해줘야 함~

즉, 추상클래스를 상속 받아서 완전한 클래스를 만든 후에 객체 생성 가능 



**접근 제어자**

- 접근 제어자가 사용될 수 있는 곳 - 클래스, 멤버변수, 메서드, 생성자
- 아래 4개 중 하나만 사용 가능

**private** 같은 클래스 내에서만 접근이 가능하다

**(default)** 같은 패키지 내에서만 접근이 가능하다

**protected** 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하다

**public** 접근 제한이 전혀 없다

![image-20220615150118310](Ch07.객체지향프로그래밍2.assets/image-20220615150118310.png)

- class 앞에는 public, default만 가능
- 멤버 앞에는 넷 다 가능

![image-20220615150457302](Ch07.객체지향프로그래밍2.assets/image-20220615150457302.png)

```java
package pkg1;

// public class 이름이랑 소스 파일 이름이랑 일치해야 함
public class MyParent { // 접근제어자 default => public 붙여줘야 함 but 하나의 소스 파일에 public 하나만 있어야 함
    private int prv; // 같은 클래스
            int dft; // 같은 패키지
    protected int prt; // 같은 패키지 + 자손(다른 패키지)
    public  int pub; // 접근제한 없음.

    public void printMembers() {
        System.out.println(prv);
        System.out.println(dft);
        System.out.println(prt);
        System.out.println(pub);
    }
}

class MyParentTest { // but 하나의 소스 파일에 public 하나만 있어야 함 => 얘를 default로 바꿔줌
    public static void main(String[] args) {
        MyParent p = new MyParent();
//        System.out.println(p.prv);
        System.out.println(p.dft);
        System.out.println(p.prt);
        System.out.println(p.pub);
    }
}
```

```java
package pkg2;

import pkg1.MyParent; // ctrl alt O
// import 안 썼을 시 pkg1.MyParent 쓰면 됨

class MyChild extends MyParent {
    public void printMembers() {
//        System.out.println(prv);
//        System.out.println(dft);
        System.out.println(prt);
        System.out.println(pub);
    }
}

public class MyParentTest2 {
    public static void main(String[] args) {
        MyParent p = new MyParent();
//        System.out.println(p.prv);
//        System.out.println(p.dft);
//        System.out.println(p.prt);
        System.out.println(p.pub);
    }
}
```

<img src="Ch07.객체지향프로그래밍2.assets/image-20220621193901364.png" alt="image-20220621193901364" style="zoom:67%;" />



**캡슐화와 접근 제어자**

접근 제어자를 사용하는 이유

- 외부로부터 데이터를 보호하기 위해서
  - 바로 접근 가능하게 하면 0~23시간까지 가능인데 25가 들어가게 됨


![image-20220621194538052](Ch07.객체지향프로그래밍2.assets/image-20220621194538052.png)

```java
public class Time {
    // 접근 제어자를 private으로 하여 외부에서 직접 접근하지 못하도록 한다.
    private int hour;
    private int minute;
    private int second;
    
    public int getHour() { return hour; }
    // 메서드는 public. 간접 접근 허용
    public void setHout(int hour) {
        if (hour < 0 || hour > 23) return; // 값을 보호
        this.hour = hour;
    }
}
```

- 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서

```java
class Time {
    private int hour; // 0~23 사이의 값을 가져야함.
    private int minute;
    private int second;

    public void setHour(int hour) {
        // 메서드 추출 단축키 ctrl alt shift T
        if (isValidHour(hour)) return;

        this.hour = hour;
    }
    // 매개변수로 넘겨진 hour가 유효한지 확인해서 알려주는 메서드
    // 이 안에서 밖에 안 써서 public으로 쓸 필요 x
    private boolean isValidHour(int hour) {
        return hour < 0 || hour > 23;
    }

    public int getHour() { return hour; };
}

public class TimeTest {
    public static void main(String[] args) {
        Time t = new Time();
//        t.hour = -100;
        t.setHour(21);
        System.out.println(t.getHour());
        t.setHour(100);
        System.out.println(t.getHour());
    }
}
```



**getter와 setter**

**getter**: 데이터를 읽어오는 역할

**setter**: private으로 선언된 필드의 값을 수정하고자 할 때 필요. private 필드는 직접 접근할 수 없게 되어있으므로, 객체는 입력 값을 setter 메소드의 매개값으로 넘겨주고 값을 검사하고 나서 그 값이 필드의 값으로 적절한 경우에만 저장



## 5. 다형성

- 여러 가지 형태를 가질 수 있는 능력(사전적 정의)

- 조상 타입 참조 변수로 자손 타입 객체를 다루는 것(진짜 의미)

- 장점 2가지. 굉장한 유연성을 줌

```java
Tv t = new SmartTv(); // 타입 불일치 OK
```

```java
class Tv {
    boolean power;
    int channel;
    
    void power() { power = !power; }
    void channelUp() { ++channel; }
    void channelDown() { --channel; }
}

class SmartTv extends Tv {
    String text;
    void caption() { /*내용 생략*/ }
}
```

![image-20220621205646064](Ch07.객체지향프로그래밍2.assets/image-20220621205646064.png)



- 객체와 참조변수의 타입이 일치할 때와 일치하지 않을 때의 차이

```java
SmartTv s = new SmartTv(); // 참조 변수와 인스턴스의 타입이 일치
Tv t = new SmartTv(); // 조상 타입 참조변수로 자손 타입 인스턴스 참조
```

![image-20220621205942209](Ch07.객체지향프로그래밍2.assets/image-20220621205942209.png)



- 자손 타입의 참조변수로 조상 타입의 객체를 가리킬 수는 없다!!

```java
Tv t = new SmartTv(); // O, 허용
SmartTv s = new Tv(); // X, 에러
```



Q. 참조변수의 타입은 인스턴스의 타입과 반드시 일치해야 하나요?

No, 다형성



Q. 참조변수가 조상타입(5)일 때와 자손타입(7)일 때의 차이?

사용할 수 있는 멤버의 개수 달라짐



Q. 자손타입의 참조변수로 조상타입의 객체 가리킬 수 있나요?

No
